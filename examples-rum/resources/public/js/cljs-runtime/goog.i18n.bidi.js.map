{
"version":3,
"file":"goog.i18n.bidi.js",
"lineCount":318,
"mappings":"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",
"sources":["goog/i18n/bidi.js"],
"sourcesContent":["// Copyright 2007 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Utility functions for supporting Bidi issues.\n */\n\n\n/**\n * Namespace for bidi supporting functions.\n */\ngoog.provide('goog.i18n.bidi');\ngoog.provide('goog.i18n.bidi.Dir');\ngoog.provide('goog.i18n.bidi.DirectionalString');\ngoog.provide('goog.i18n.bidi.Format');\n\n\n/**\n * @define {boolean} FORCE_RTL forces the {@link goog.i18n.bidi.IS_RTL} constant\n * to say that the current locale is a RTL locale.  This should only be used\n * if you want to override the default behavior for deciding whether the\n * current locale is RTL or not.\n *\n * {@see goog.i18n.bidi.IS_RTL}\n */\ngoog.i18n.bidi.FORCE_RTL = goog.define('goog.i18n.bidi.FORCE_RTL', false);\n\n\n/**\n * Constant that defines whether or not the current locale is a RTL locale.\n * If {@link goog.i18n.bidi.FORCE_RTL} is not true, this constant will default\n * to check that {@link goog.LOCALE} is one of a few major RTL locales.\n *\n * <p>This is designed to be a maximally efficient compile-time constant. For\n * example, for the default goog.LOCALE, compiling\n * \"if (goog.i18n.bidi.IS_RTL) alert('rtl') else {}\" should produce no code. It\n * is this design consideration that limits the implementation to only\n * supporting a few major RTL locales, as opposed to the broader repertoire of\n * something like goog.i18n.bidi.isRtlLanguage.\n *\n * <p>Since this constant refers to the directionality of the locale, it is up\n * to the caller to determine if this constant should also be used for the\n * direction of the UI.\n *\n * {@see goog.LOCALE}\n *\n * @type {boolean}\n *\n * TODO(user): write a test that checks that this is a compile-time constant.\n */\n// LINT.IfChange\ngoog.i18n.bidi.IS_RTL =\n    goog.i18n.bidi.FORCE_RTL ||\n    ((goog.LOCALE.substring(0, 2).toLowerCase() == 'ar' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'fa' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'he' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'iw' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'ps' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'sd' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'ug' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'ur' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'yi') &&\n     (goog.LOCALE.length == 2 || goog.LOCALE.substring(2, 3) == '-' ||\n      goog.LOCALE.substring(2, 3) == '_')) ||\n    (  // Specific to CKB (Central Kurdish)\n        goog.LOCALE.length >= 3 &&\n        goog.LOCALE.substring(0, 3).toLowerCase() == 'ckb' &&\n        (goog.LOCALE.length == 3 || goog.LOCALE.substring(3, 4) == '-' ||\n         goog.LOCALE.substring(3, 4) == '_')) ||\n    (  // 2 letter language codes with RTL scripts\n        goog.LOCALE.length >= 7 &&\n        ((goog.LOCALE.substring(2, 3) == '-' ||\n          goog.LOCALE.substring(2, 3) == '_') &&\n         (goog.LOCALE.substring(3, 7).toLowerCase() == 'adlm' ||\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'arab' ||\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'hebr' ||\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'nkoo' ||\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'rohg' ||\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'thaa'))) ||\n    (  // 3 letter languages codes with RTL scripts\n        goog.LOCALE.length >= 8 &&\n        ((goog.LOCALE.substring(3, 4) == '-' ||\n          goog.LOCALE.substring(3, 4) == '_') &&\n         (goog.LOCALE.substring(4, 8).toLowerCase() == 'adlm' ||\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'arab' ||\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'hebr' ||\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'nkoo' ||\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'rohg' ||\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'thaa')));\n//    closure/RtlLocalesTest.java)\n\n// TODO(b/77919903): Add additional scripts and languages that are RTL,\n// e.g., mende, samaritan, etc.\n\n\n/**\n * Unicode formatting characters and directionality string constants.\n * @enum {string}\n */\ngoog.i18n.bidi.Format = {\n  /** Unicode \"Left-To-Right Embedding\" (LRE) character. */\n  LRE: '\\u202A',\n  /** Unicode \"Right-To-Left Embedding\" (RLE) character. */\n  RLE: '\\u202B',\n  /** Unicode \"Pop Directional Formatting\" (PDF) character. */\n  PDF: '\\u202C',\n  /** Unicode \"Left-To-Right Mark\" (LRM) character. */\n  LRM: '\\u200E',\n  /** Unicode \"Right-To-Left Mark\" (RLM) character. */\n  RLM: '\\u200F'\n};\n\n\n/**\n * Directionality enum.\n * @enum {number}\n */\ngoog.i18n.bidi.Dir = {\n  /**\n   * Left-to-right.\n   */\n  LTR: 1,\n\n  /**\n   * Right-to-left.\n   */\n  RTL: -1,\n\n  /**\n   * Neither left-to-right nor right-to-left.\n   */\n  NEUTRAL: 0\n};\n\n\n/**\n * 'right' string constant.\n * @type {string}\n */\ngoog.i18n.bidi.RIGHT = 'right';\n\n\n/**\n * 'left' string constant.\n * @type {string}\n */\ngoog.i18n.bidi.LEFT = 'left';\n\n\n/**\n * 'left' if locale is RTL, 'right' if not.\n * @type {string}\n */\ngoog.i18n.bidi.I18N_RIGHT =\n    goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT;\n\n\n/**\n * 'right' if locale is RTL, 'left' if not.\n * @type {string}\n */\ngoog.i18n.bidi.I18N_LEFT =\n    goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;\n\n\n/**\n * Convert a directionality given in various formats to a goog.i18n.bidi.Dir\n * constant. Useful for interaction with different standards of directionality\n * representation.\n *\n * @param {goog.i18n.bidi.Dir|number|boolean|null} givenDir Directionality given\n *     in one of the following formats:\n *     1. A goog.i18n.bidi.Dir constant.\n *     2. A number (positive = LTR, negative = RTL, 0 = neutral).\n *     3. A boolean (true = RTL, false = LTR).\n *     4. A null for unknown directionality.\n * @param {boolean=} opt_noNeutral Whether a givenDir of zero or\n *     goog.i18n.bidi.Dir.NEUTRAL should be treated as null, i.e. unknown, in\n *     order to preserve legacy behavior.\n * @return {?goog.i18n.bidi.Dir} A goog.i18n.bidi.Dir constant matching the\n *     given directionality. If given null, returns null (i.e. unknown).\n */\ngoog.i18n.bidi.toDir = function(givenDir, opt_noNeutral) {\n  if (typeof givenDir == 'number') {\n    // This includes the non-null goog.i18n.bidi.Dir case.\n    return givenDir > 0 ?\n        goog.i18n.bidi.Dir.LTR :\n        givenDir < 0 ? goog.i18n.bidi.Dir.RTL :\n                       opt_noNeutral ? null : goog.i18n.bidi.Dir.NEUTRAL;\n  } else if (givenDir == null) {\n    return null;\n  } else {\n    // Must be typeof givenDir == 'boolean'.\n    return givenDir ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;\n  }\n};\n\n\n/**\n * A practical pattern to identify strong LTR character in the BMP.\n * This pattern is not theoretically correct according to the Unicode\n * standard. It is simplified for performance and small code size.\n * It also partially supports LTR scripts beyond U+FFFF by including\n * UTF-16 high surrogate values corresponding to mostly L-class code\n * point ranges.\n * However, low surrogate values and private-use regions are not included\n * in this RegEx.\n * @type {string}\n * @private\n */\ngoog.i18n.bidi.ltrChars_ =\n    'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02B8\\u0300-\\u0590\\u0900-\\u1FFF' +\n    '\\u200E\\u2C00-\\uD801\\uD804-\\uD839\\uD83C-\\uDBFF' +\n    '\\uF900-\\uFB1C\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n/**\n * A practical pattern to identify strong RTL character. This pattern is not\n * theoretically correct according to the Unicode standard. It is simplified\n * for performance and small code size.\n * It also partially supports RTL scripts beyond U+FFFF by including\n * UTF-16 high surrogate values corresponding to mostly R- or AL-class\n * code point ranges.\n * However, low surrogate values and private-use regions are not included\n * in this RegEx.\n * @type {string}\n * @private\n */\ngoog.i18n.bidi.rtlChars_ =\n    '\\u0591-\\u06EF\\u06FA-\\u08FF\\u200F\\uD802-\\uD803\\uD83A-\\uD83B' +\n    '\\uFB1D-\\uFDFF\\uFE70-\\uFEFC';\n\n/**\n * Simplified regular expression for an HTML tag (opening or closing) or an HTML\n * escape. We might want to skip over such expressions when estimating the text\n * directionality.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g;\n\n\n/**\n * Returns the input text with spaces instead of HTML tags or HTML escapes, if\n * opt_isStripNeeded is true. Else returns the input as is.\n * Useful for text directionality estimation.\n * Note: the function should not be used in other contexts; it is not 100%\n * correct, but rather a good-enough implementation for directionality\n * estimation purposes.\n * @param {string} str The given string.\n * @param {boolean=} opt_isStripNeeded Whether to perform the stripping.\n *     Default: false (to retain consistency with calling functions).\n * @return {string} The given string cleaned of HTML tags / escapes.\n * @private\n */\ngoog.i18n.bidi.stripHtmlIfNeeded_ = function(str, opt_isStripNeeded) {\n  return opt_isStripNeeded ? str.replace(goog.i18n.bidi.htmlSkipReg_, '') : str;\n};\n\n\n/**\n * Regular expression to check for RTL characters, BMP and high surrogate.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.rtlCharReg_ = new RegExp('[' + goog.i18n.bidi.rtlChars_ + ']');\n\n\n/**\n * Regular expression to check for LTR characters.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.ltrCharReg_ = new RegExp('[' + goog.i18n.bidi.ltrChars_ + ']');\n\n\n/**\n * Test whether the given string has any RTL characters in it.\n * @param {string} str The given string that need to be tested.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether the string contains RTL characters.\n */\ngoog.i18n.bidi.hasAnyRtl = function(str, opt_isHtml) {\n  return goog.i18n.bidi.rtlCharReg_.test(\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\n\n\n/**\n * Test whether the given string has any RTL characters in it.\n * @param {string} str The given string that need to be tested.\n * @return {boolean} Whether the string contains RTL characters.\n * @deprecated Use hasAnyRtl.\n */\ngoog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl;\n\n\n/**\n * Test whether the given string has any LTR characters in it.\n * @param {string} str The given string that need to be tested.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether the string contains LTR characters.\n */\ngoog.i18n.bidi.hasAnyLtr = function(str, opt_isHtml) {\n  return goog.i18n.bidi.ltrCharReg_.test(\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\n\n\n/**\n * Regular expression pattern to check if the first character in the string\n * is LTR.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.ltrRe_ = new RegExp('^[' + goog.i18n.bidi.ltrChars_ + ']');\n\n\n/**\n * Regular expression pattern to check if the first character in the string\n * is RTL.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.rtlRe_ = new RegExp('^[' + goog.i18n.bidi.rtlChars_ + ']');\n\n\n/**\n * Check if the first character in the string is RTL or not.\n * @param {string} str The given string that need to be tested.\n * @return {boolean} Whether the first character in str is an RTL char.\n */\ngoog.i18n.bidi.isRtlChar = function(str) {\n  return goog.i18n.bidi.rtlRe_.test(str);\n};\n\n\n/**\n * Check if the first character in the string is LTR or not.\n * @param {string} str The given string that need to be tested.\n * @return {boolean} Whether the first character in str is an LTR char.\n */\ngoog.i18n.bidi.isLtrChar = function(str) {\n  return goog.i18n.bidi.ltrRe_.test(str);\n};\n\n\n/**\n * Check if the first character in the string is neutral or not.\n * @param {string} str The given string that need to be tested.\n * @return {boolean} Whether the first character in str is a neutral char.\n */\ngoog.i18n.bidi.isNeutralChar = function(str) {\n  return !goog.i18n.bidi.isLtrChar(str) && !goog.i18n.bidi.isRtlChar(str);\n};\n\n\n/**\n * Regular expressions to check if a piece of text is of LTR directionality\n * on first character with strong directionality.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.ltrDirCheckRe_ = new RegExp(\n    '^[^' + goog.i18n.bidi.rtlChars_ + ']*[' + goog.i18n.bidi.ltrChars_ + ']');\n\n\n/**\n * Regular expressions to check if a piece of text is of RTL directionality\n * on first character with strong directionality.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.rtlDirCheckRe_ = new RegExp(\n    '^[^' + goog.i18n.bidi.ltrChars_ + ']*[' + goog.i18n.bidi.rtlChars_ + ']');\n\n\n/**\n * Check whether the first strongly directional character (if any) is RTL.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether RTL directionality is detected using the first\n *     strongly-directional character method.\n */\ngoog.i18n.bidi.startsWithRtl = function(str, opt_isHtml) {\n  return goog.i18n.bidi.rtlDirCheckRe_.test(\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\n\n\n/**\n * Check whether the first strongly directional character (if any) is RTL.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether RTL directionality is detected using the first\n *     strongly-directional character method.\n * @deprecated Use startsWithRtl.\n */\ngoog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl;\n\n\n/**\n * Check whether the first strongly directional character (if any) is LTR.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether LTR directionality is detected using the first\n *     strongly-directional character method.\n */\ngoog.i18n.bidi.startsWithLtr = function(str, opt_isHtml) {\n  return goog.i18n.bidi.ltrDirCheckRe_.test(\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\n\n\n/**\n * Check whether the first strongly directional character (if any) is LTR.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether LTR directionality is detected using the first\n *     strongly-directional character method.\n * @deprecated Use startsWithLtr.\n */\ngoog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr;\n\n\n/**\n * Regular expression to check if a string looks like something that must\n * always be LTR even in RTL text, e.g. a URL. When estimating the\n * directionality of text containing these, we treat these as weakly LTR,\n * like numbers.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.isRequiredLtrRe_ = /^http:\\/\\/.*/;\n\n\n/**\n * Check whether the input string either contains no strongly directional\n * characters or looks like a url.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether neutral directionality is detected.\n */\ngoog.i18n.bidi.isNeutralText = function(str, opt_isHtml) {\n  str = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml);\n  return goog.i18n.bidi.isRequiredLtrRe_.test(str) ||\n      !goog.i18n.bidi.hasAnyLtr(str) && !goog.i18n.bidi.hasAnyRtl(str);\n};\n\n\n/**\n * Regular expressions to check if the last strongly-directional character in a\n * piece of text is LTR.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp(\n    '[' + goog.i18n.bidi.ltrChars_ + ']' +\n    '[^' + goog.i18n.bidi.rtlChars_ + ']*$');\n\n\n/**\n * Regular expressions to check if the last strongly-directional character in a\n * piece of text is RTL.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp(\n    '[' + goog.i18n.bidi.rtlChars_ + ']' +\n    '[^' + goog.i18n.bidi.ltrChars_ + ']*$');\n\n\n/**\n * Check if the exit directionality a piece of text is LTR, i.e. if the last\n * strongly-directional character in the string is LTR.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether LTR exit directionality was detected.\n */\ngoog.i18n.bidi.endsWithLtr = function(str, opt_isHtml) {\n  return goog.i18n.bidi.ltrExitDirCheckRe_.test(\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\n\n\n/**\n * Check if the exit directionality a piece of text is LTR, i.e. if the last\n * strongly-directional character in the string is LTR.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether LTR exit directionality was detected.\n * @deprecated Use endsWithLtr.\n */\ngoog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr;\n\n\n/**\n * Check if the exit directionality a piece of text is RTL, i.e. if the last\n * strongly-directional character in the string is RTL.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether RTL exit directionality was detected.\n */\ngoog.i18n.bidi.endsWithRtl = function(str, opt_isHtml) {\n  return goog.i18n.bidi.rtlExitDirCheckRe_.test(\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\n\n\n/**\n * Check if the exit directionality a piece of text is RTL, i.e. if the last\n * strongly-directional character in the string is RTL.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether RTL exit directionality was detected.\n * @deprecated Use endsWithRtl.\n */\ngoog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl;\n\n\n/**\n * A regular expression for matching right-to-left language codes.\n * See {@link #isRtlLanguage} for the design.\n * Note that not all RTL scripts are included.\n * @type {!RegExp}\n * @private\n */\ngoog.i18n.bidi.rtlLocalesRe_ = new RegExp(\n    '^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|' +\n        '.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))' +\n        '(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)',\n    'i');\n\n\n/**\n * Check if a BCP 47 / III language code indicates an RTL language, i.e. either:\n * - a language code explicitly specifying one of the right-to-left scripts,\n *   e.g. \"az-Arab\", or<p>\n * - a language code specifying one of the languages normally written in a\n *   right-to-left script, e.g. \"fa\" (Farsi), except ones explicitly specifying\n *   Latin or Cyrillic script (which are the usual LTR alternatives).<p>\n * The list of right-to-left scripts appears in the 100-199 range in\n * http://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and\n * Hebrew are by far the most widely used. We also recognize Thaana, and N'Ko,\n * which also have significant modern usage. Adlam and Rohingya\n * scripts are now included since they can be expected to be used in the\n * future. The rest (Syriac, Samaritan, Mandaic, etc.) seem to have extremely\n * limited or no modern usage and are not recognized to save on code size. The\n * languages usually written in a right-to-left script are taken as those with\n * Suppress-Script: Hebr|Arab|Thaa|Nkoo|Adlm|Rohg in\n * http://www.iana.org/assignments/language-subtag-registry,\n * as well as Central (or Sorani) Kurdish (ckb), Sindhi (sd) and Uyghur (ug).\n * Other subtags of the language code, e.g. regions like EG (Egypt), are\n * ignored.\n * @param {string} lang BCP 47 (a.k.a III) language code.\n * @return {boolean} Whether the language code is an RTL language.\n */\ngoog.i18n.bidi.isRtlLanguage = function(lang) {\n  return goog.i18n.bidi.rtlLocalesRe_.test(lang);\n};\n\n\n/**\n * Regular expression for bracket guard replacement in text.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.bracketGuardTextRe_ =\n    /(\\(.*?\\)+)|(\\[.*?\\]+)|(\\{.*?\\}+)|(<.*?>+)/g;\n\n\n/**\n * Apply bracket guard using LRM and RLM. This is to address the problem of\n * messy bracket display frequently happens in RTL layout.\n * This function works for plain text, not for HTML. In HTML, the opening\n * bracket might be in a different context than the closing bracket (such as\n * an attribute value).\n * @param {string} s The string that need to be processed.\n * @param {boolean=} opt_isRtlContext specifies default direction (usually\n *     direction of the UI).\n * @return {string} The processed string, with all bracket guarded.\n */\ngoog.i18n.bidi.guardBracketInText = function(s, opt_isRtlContext) {\n  const useRtl = opt_isRtlContext === undefined ? goog.i18n.bidi.hasAnyRtl(s) :\n                                                  opt_isRtlContext;\n  const mark = useRtl ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM;\n  return s.replace(goog.i18n.bidi.bracketGuardTextRe_, mark + '$&' + mark);\n};\n\n\n/**\n * Enforce the html snippet in RTL directionality regardless of overall context.\n * If the html piece was enclosed by tag, dir will be applied to existing\n * tag, otherwise a span tag will be added as wrapper. For this reason, if\n * html snippet starts with a tag, this tag must enclose the whole piece. If\n * the tag already has a dir specified, this new one will override existing\n * one in behavior (tested on FF and IE).\n * @param {string} html The string that need to be processed.\n * @return {string} The processed string, with directionality enforced to RTL.\n */\ngoog.i18n.bidi.enforceRtlInHtml = function(html) {\n  if (html.charAt(0) == '<') {\n    return html.replace(/<\\w+/, '$& dir=rtl');\n  }\n  // '\\n' is important for FF so that it won't incorrectly merge span groups\n  return '\\n<span dir=rtl>' + html + '</span>';\n};\n\n\n/**\n * Enforce RTL on both end of the given text piece using unicode BiDi formatting\n * characters RLE and PDF.\n * @param {string} text The piece of text that need to be wrapped.\n * @return {string} The wrapped string after process.\n */\ngoog.i18n.bidi.enforceRtlInText = function(text) {\n  return goog.i18n.bidi.Format.RLE + text + goog.i18n.bidi.Format.PDF;\n};\n\n\n/**\n * Enforce the html snippet in RTL directionality regardless or overall context.\n * If the html piece was enclosed by tag, dir will be applied to existing\n * tag, otherwise a span tag will be added as wrapper. For this reason, if\n * html snippet starts with a tag, this tag must enclose the whole piece. If\n * the tag already has a dir specified, this new one will override existing\n * one in behavior (tested on FF and IE).\n * @param {string} html The string that need to be processed.\n * @return {string} The processed string, with directionality enforced to RTL.\n */\ngoog.i18n.bidi.enforceLtrInHtml = function(html) {\n  if (html.charAt(0) == '<') {\n    return html.replace(/<\\w+/, '$& dir=ltr');\n  }\n  // '\\n' is important for FF so that it won't incorrectly merge span groups\n  return '\\n<span dir=ltr>' + html + '</span>';\n};\n\n\n/**\n * Enforce LTR on both end of the given text piece using unicode BiDi formatting\n * characters LRE and PDF.\n * @param {string} text The piece of text that need to be wrapped.\n * @return {string} The wrapped string after process.\n */\ngoog.i18n.bidi.enforceLtrInText = function(text) {\n  return goog.i18n.bidi.Format.LRE + text + goog.i18n.bidi.Format.PDF;\n};\n\n\n/**\n * Regular expression to find dimensions such as \"padding: .3 0.4ex 5px 6;\"\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.dimensionsRe_ =\n    /:\\s*([.\\d][.\\w]*)\\s+([.\\d][.\\w]*)\\s+([.\\d][.\\w]*)\\s+([.\\d][.\\w]*)/g;\n\n\n/**\n * Regular expression for left.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.leftRe_ = /left/gi;\n\n\n/**\n * Regular expression for right.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.rightRe_ = /right/gi;\n\n\n/**\n * Placeholder regular expression for swapping.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.tempRe_ = /%%%%/g;\n\n\n/**\n * Swap location parameters and 'left'/'right' in CSS specification. The\n * processed string will be suited for RTL layout. Though this function can\n * cover most cases, there are always exceptions. It is suggested to put\n * those exceptions in separate group of CSS string.\n * @param {string} cssStr CSS spefication string.\n * @return {string} Processed CSS specification string.\n */\ngoog.i18n.bidi.mirrorCSS = function(cssStr) {\n  return cssStr\n      .\n      // reverse dimensions\n      replace(goog.i18n.bidi.dimensionsRe_, ':$1 $4 $3 $2')\n      .replace(goog.i18n.bidi.leftRe_, '%%%%')\n      .  // swap left and right\n      replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT)\n      .replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);\n};\n\n\n/**\n * Regular expression for hebrew double quote substitution, finding quote\n * directly after hebrew characters.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\\u0591-\\u05f2])\"/g;\n\n\n/**\n * Regular expression for hebrew single quote substitution, finding quote\n * directly after hebrew characters.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.singleQuoteSubstituteRe_ = /([\\u0591-\\u05f2])'/g;\n\n\n/**\n * Replace the double and single quote directly after a Hebrew character with\n * GERESH and GERSHAYIM. In such case, most likely that's user intention.\n * @param {string} str String that need to be processed.\n * @return {string} Processed string with double/single quote replaced.\n */\ngoog.i18n.bidi.normalizeHebrewQuote = function(str) {\n  return str.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, '$1\\u05f4')\n      .replace(goog.i18n.bidi.singleQuoteSubstituteRe_, '$1\\u05f3');\n};\n\n\n/**\n * Regular expression to split a string into \"words\" for directionality\n * estimation based on relative word counts.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.wordSeparatorRe_ = /\\s+/;\n\n\n/**\n * Regular expression to check if a string contains any numerals. Used to\n * differentiate between completely neutral strings and those containing\n * numbers, which are weakly LTR.\n *\n * Native Arabic digits (\\u0660 - \\u0669) are not included because although they\n * do flow left-to-right inside a number, this is the case even if the  overall\n * directionality is RTL, and a mathematical expression using these digits is\n * supposed to flow right-to-left overall, including unary plus and minus\n * appearing to the right of a number, and this does depend on the overall\n * directionality being RTL. The digits used in Farsi (\\u06F0 - \\u06F9), on the\n * other hand, are included, since Farsi math (including unary plus and minus)\n * does flow left-to-right.\n * TODO: Consider other systems of digits, e.g., Adlam.\n *\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.hasNumeralsRe_ = /[\\d\\u06f0-\\u06f9]/;\n\n\n/**\n * This constant controls threshold of RTL directionality.\n * @type {number}\n * @private\n */\ngoog.i18n.bidi.rtlDetectionThreshold_ = 0.40;\n\n\n/**\n * Estimates the directionality of a string based on relative word counts.\n * If the number of RTL words is above a certain percentage of the total number\n * of strongly directional words, returns RTL.\n * Otherwise, if any words are strongly or weakly LTR, returns LTR.\n * Otherwise, returns UNKNOWN, which is used to mean \"neutral\".\n * Numbers are counted as weakly LTR.\n * @param {string} str The string to be checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {goog.i18n.bidi.Dir} Estimated overall directionality of `str`.\n */\ngoog.i18n.bidi.estimateDirection = function(str, opt_isHtml) {\n  let rtlCount = 0;\n  let totalCount = 0;\n  let hasWeaklyLtr = false;\n  const tokens = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml)\n                     .split(goog.i18n.bidi.wordSeparatorRe_);\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (goog.i18n.bidi.startsWithRtl(token)) {\n      rtlCount++;\n      totalCount++;\n    } else if (goog.i18n.bidi.isRequiredLtrRe_.test(token)) {\n      hasWeaklyLtr = true;\n    } else if (goog.i18n.bidi.hasAnyLtr(token)) {\n      totalCount++;\n    } else if (goog.i18n.bidi.hasNumeralsRe_.test(token)) {\n      hasWeaklyLtr = true;\n    }\n  }\n\n  return totalCount == 0 ?\n      (hasWeaklyLtr ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL) :\n      (rtlCount / totalCount > goog.i18n.bidi.rtlDetectionThreshold_ ?\n           goog.i18n.bidi.Dir.RTL :\n           goog.i18n.bidi.Dir.LTR);\n};\n\n\n/**\n * Check the directionality of a piece of text, return true if the piece of\n * text should be laid out in RTL direction.\n * @param {string} str The piece of text that need to be detected.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether this piece of text should be laid out in RTL.\n */\ngoog.i18n.bidi.detectRtlDirectionality = function(str, opt_isHtml) {\n  return goog.i18n.bidi.estimateDirection(str, opt_isHtml) ==\n      goog.i18n.bidi.Dir.RTL;\n};\n\n\n/**\n * Sets text input element's directionality and text alignment based on a\n * given directionality. Does nothing if the given directionality is unknown or\n * neutral.\n * @param {Element} element Input field element to set directionality to.\n * @param {goog.i18n.bidi.Dir|number|boolean|null} dir Desired directionality,\n *     given in one of the following formats:\n *     1. A goog.i18n.bidi.Dir constant.\n *     2. A number (positive = LRT, negative = RTL, 0 = neutral).\n *     3. A boolean (true = RTL, false = LTR).\n *     4. A null for unknown directionality.\n */\ngoog.i18n.bidi.setElementDirAndAlign = function(element, dir) {\n  if (element) {\n    const htmlElement = /** @type {!HTMLElement} */ (element);\n    dir = goog.i18n.bidi.toDir(dir);\n    if (dir) {\n      htmlElement.style.textAlign = dir == goog.i18n.bidi.Dir.RTL ?\n          goog.i18n.bidi.RIGHT :\n          goog.i18n.bidi.LEFT;\n      htmlElement.dir = dir == goog.i18n.bidi.Dir.RTL ? 'rtl' : 'ltr';\n    }\n  }\n};\n\n\n/**\n * Sets element dir based on estimated directionality of the given text.\n * @param {!Element} element\n * @param {string} text\n */\ngoog.i18n.bidi.setElementDirByTextDirectionality = function(element, text) {\n  const htmlElement = /** @type {!HTMLElement} */ (element);\n  switch (goog.i18n.bidi.estimateDirection(text)) {\n    case (goog.i18n.bidi.Dir.LTR):\n      htmlElement.dir = 'ltr';\n      break;\n    case (goog.i18n.bidi.Dir.RTL):\n      htmlElement.dir = 'rtl';\n      break;\n    default:\n      // Default for no direction, inherit from document.\n      htmlElement.removeAttribute('dir');\n  }\n};\n\n\n\n/**\n * Strings that have an (optional) known direction.\n *\n * Implementations of this interface are string-like objects that carry an\n * attached direction, if known.\n * @interface\n */\ngoog.i18n.bidi.DirectionalString = function() {};\n\n\n/**\n * Interface marker of the DirectionalString interface.\n *\n * This property can be used to determine at runtime whether or not an object\n * implements this interface.  All implementations of this interface set this\n * property to `true`.\n * @type {boolean}\n */\ngoog.i18n.bidi.DirectionalString.prototype\n    .implementsGoogI18nBidiDirectionalString;\n\n\n/**\n * Retrieves this object's known direction (if any).\n * @return {?goog.i18n.bidi.Dir} The known direction. Null if unknown.\n */\ngoog.i18n.bidi.DirectionalString.prototype.getDirection;\n"],
"names":["goog","provide","i18n","bidi","FORCE_RTL","define","IS_RTL","LOCALE","substring","toLowerCase","length","Format","LRE","RLE","PDF","LRM","RLM","Dir","LTR","RTL","NEUTRAL","RIGHT","LEFT","I18N_RIGHT","I18N_LEFT","toDir","goog.i18n.bidi.toDir","givenDir","opt_noNeutral","ltrChars_","rtlChars_","htmlSkipReg_","stripHtmlIfNeeded_","goog.i18n.bidi.stripHtmlIfNeeded_","str","opt_isStripNeeded","replace","rtlCharReg_","RegExp","ltrCharReg_","hasAnyRtl","goog.i18n.bidi.hasAnyRtl","opt_isHtml","test","hasRtlChar","hasAnyLtr","goog.i18n.bidi.hasAnyLtr","ltrRe_","rtlRe_","isRtlChar","goog.i18n.bidi.isRtlChar","isLtrChar","goog.i18n.bidi.isLtrChar","isNeutralChar","goog.i18n.bidi.isNeutralChar","ltrDirCheckRe_","rtlDirCheckRe_","startsWithRtl","goog.i18n.bidi.startsWithRtl","isRtlText","startsWithLtr","goog.i18n.bidi.startsWithLtr","isLtrText","isRequiredLtrRe_","isNeutralText","goog.i18n.bidi.isNeutralText","ltrExitDirCheckRe_","rtlExitDirCheckRe_","endsWithLtr","goog.i18n.bidi.endsWithLtr","isLtrExitText","endsWithRtl","goog.i18n.bidi.endsWithRtl","isRtlExitText","rtlLocalesRe_","isRtlLanguage","goog.i18n.bidi.isRtlLanguage","lang","bracketGuardTextRe_","guardBracketInText","goog.i18n.bidi.guardBracketInText","s","opt_isRtlContext","useRtl","undefined","mark","enforceRtlInHtml","goog.i18n.bidi.enforceRtlInHtml","html","charAt","enforceRtlInText","goog.i18n.bidi.enforceRtlInText","text","enforceLtrInHtml","goog.i18n.bidi.enforceLtrInHtml","enforceLtrInText","goog.i18n.bidi.enforceLtrInText","dimensionsRe_","leftRe_","rightRe_","tempRe_","mirrorCSS","goog.i18n.bidi.mirrorCSS","cssStr","doubleQuoteSubstituteRe_","singleQuoteSubstituteRe_","normalizeHebrewQuote","goog.i18n.bidi.normalizeHebrewQuote","wordSeparatorRe_","hasNumeralsRe_","rtlDetectionThreshold_","estimateDirection","goog.i18n.bidi.estimateDirection","rtlCount","totalCount","hasWeaklyLtr","tokens","split","i","token","detectRtlDirectionality","goog.i18n.bidi.detectRtlDirectionality","setElementDirAndAlign","goog.i18n.bidi.setElementDirAndAlign","element","dir","htmlElement","style","textAlign","setElementDirByTextDirectionality","goog.i18n.bidi.setElementDirByTextDirectionality","removeAttribute","DirectionalString","goog.i18n.bidi.DirectionalString","prototype","implementsGoogI18nBidiDirectionalString","getDirection"]
}
