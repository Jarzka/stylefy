{"version":3,"sources":["stylefy/impl/hashing.cljc"],"mappings":";;;;AAIA,AAAA,AAAKA;AACL,AAAKC,AAAyB,AAAA,AAACC;AAE/B;;;AAAA,AAAOC,AAEJC;AAFH,AAGE,AAAQ,AACE,AAAA,AAAMA,AACN,AAASA,AACT,AAAAE,AAAUF;AAHpB;AAAA,AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAIQ,AAAA,AAA0E,AAACE,AAAOH;;;AAE1F,AAAM,AAAA,AAAMA;AAAqBJ;;AAAjC,AACM,AAASI;AAAqBA;;AADpC,AAEM,AAAAE,AAAUF;AAAqB,AAACI,AAAKJ;;AAF3C;;;;;AAIF,AAAA,AAAMK,AAAYC;AAAlB,AACE,AAAM,AAACC,AAAID;AAAX,AACE,AAAME,AAAsB,AAACC,AAGC,AAAKC,AAAOC;AAAZ,AACE,AAAMC,AAAW,AAACD,AAAAA,AAAAA,AAASL,AAAAA;AAA3B,AACE,AAAI,AAACO,AAAuBD;AAC1B,AAACE,AAAMJ,AAAOC,AAAS,AAACI,AAAoBH;;AAC5CF;;AAPR,AASE,AAACM,AAAK,AAACC,AAA8BX;AAC7DY,AAAe,AAACC,AAAMb,AAAME;AAI5BU,AAAe,AAAA,AAAA,AAACE,AAAOF;AAGvBG,AAAa,AAAA,AAAAC,AAAKzB,AACH,AAACE,AAA0B,AAAA,AAA4BO,AACvDV;AAnBrB,AAoBE,AAAA,AAAKyB,AAAiB,AAACE,AAAKL;;AArBhC;;;AAuBF,AAAA,AAAMM,AAA0BC;AAAhC,AACE,AAACC,AAAO7B,AAAyB,AAAC8B,AAAQ,AAAA,AAA2BF","names":["stylefy.impl.hashing/default-class-prefix","stylefy.impl.hashing/use-custom-class-prefix?","cljs.core.atom","stylefy.impl.hashing/check-custom-class-prefix","custom-class-prefix","js/Error","cljs.core/Keyword","cljs.core.pr_str","cljs.core/name","stylefy.impl.hashing/hash-style","style","cljs.core/seq","hashable-garden-units","cljs.core.reduce","result","prop-key","prop-value","stylefy.impl.utils/is-garden-value?","cljs.core.assoc","garden.compiler/render-css","cljs.core/keys","stylefy.impl.utils/remove-special-keywords","hashable-style","cljs.core.merge","cljs.core.dissoc","class-prefix","cljs.core/deref","cljs.core/hash","stylefy.impl.hashing/init-custom-class-prefix","options","cljs.core/reset!","cljs.core/boolean"],"sourcesContent":["(ns stylefy.impl.hashing\n  (:require [stylefy.impl.utils :as utils]\n            [garden.compiler :as compiler]))\n\n(def default-class-prefix \"_stylefy\")\n(def use-custom-class-prefix? (atom false))\n\n(defn- check-custom-class-prefix\n  \"Checks that the value is valid and returns as properly formatted prefix.\"\n  [custom-class-prefix]\n  (assert (or\n            (nil? custom-class-prefix)\n            (string? custom-class-prefix)\n            (keyword? custom-class-prefix))\n          (str \"Custom class prefix should be either string, keyword or nil, got: \" (pr-str custom-class-prefix)))\n\n  (cond (nil? custom-class-prefix) default-class-prefix\n        (string? custom-class-prefix) custom-class-prefix\n        (keyword? custom-class-prefix) (name custom-class-prefix)))\n\n(defn hash-style [style]\n  (when (seq style)\n    (let [hashable-garden-units (reduce\n                                  ; Convert Garden units to CSS to make them structurally\n                                  ; hashable (different contents = different hash)\n                                  (fn [result prop-key]\n                                    (let [prop-value (prop-key style)]\n                                      (if (utils/is-garden-value? prop-value)\n                                        (assoc result prop-key (compiler/render-css prop-value))\n                                        result)))\n                                  {}\n                                  (keys (utils/remove-special-keywords style)))\n          hashable-style (merge style hashable-garden-units)\n          ; Hash style without certain special keywords:\n          ; - sub-styles is only a link to other styles, it does not define the actual properties of this style\n          ; - class-prefix is only for class naming, the style looks the same with it or without\n          hashable-style (dissoc hashable-style\n                                 :stylefy.core/sub-styles\n                                 :stylefy.core/class-prefix)\n          class-prefix (if @use-custom-class-prefix?\n                         (check-custom-class-prefix (:stylefy.core/class-prefix style))\n                         default-class-prefix)]\n      (str class-prefix \"_\" (hash hashable-style)))))\n\n(defn init-custom-class-prefix [options]\n  (reset! use-custom-class-prefix? (boolean (:use-custom-class-prefix? options))))\n"]}