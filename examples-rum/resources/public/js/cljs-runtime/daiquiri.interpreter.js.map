{"version":3,"sources":["daiquiri/interpreter.cljs"],"mappings":"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","names":["daiquiri.interpreter/create-element","type","attrs","children","js/React","daiquiri.interpreter/component-attributes","x","daiquiri.util/camel-case-keys*","m","seq__27339","cljs.core/seq","chunk__27340","count__27341","i__27342","vec__27356","cljs.core.nth","temp__5735__auto__","cljs.core/chunked-seq?","c__4550__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","vec__27363","cljs.core/first","cljs.core/next","k","v","goog.object/set","cljs.core/name","daiquiri.interpreter/element-attributes","js-attrs","cljs.core/clj->js","daiquiri.util/html-to-dom-attrs","class","cljs.core/array?","clojure.string.join","clojure.string/blank?","daiquiri.interpreter/interpret-seq","cljs.core.reduce","ret","daiquiri.interpreter/interpret","daiquiri.interpreter/element","element","vec__27378","content","daiquiri.normalize/element","p__27383","vec__27384","seq__27385","first__27386","daiquiri.interpreter/fragment","_","vec__27388","cljs.core/map?","cljs.core.into","js/React.Fragment","p__27400","vec__27401","seq__27402","first__27403","daiquiri.interpreter/interop","component","vec__27404","daiquiri.interpreter/interpret-vec","daiquiri.util/fragment?","cljs.core/keyword-identical?","daiquiri.util/element?","cljs.core/vector?","cljs.core/seq?"],"sourcesContent":["(ns daiquiri.interpreter\n  (:require [clojure.string :as str]\n            [daiquiri.normalize :as normalize]\n            [daiquiri.util :as util]\n            [cljsjs.react]\n            [goog.object :as gobj]))\n\n(defn ^js/React.Element create-element\n  \"Create a React element. Returns a JavaScript object when running\n  under ClojureScript, and a om.dom.Element record in Clojure.\"\n  [type attrs children]\n  (.apply (.-createElement js/React) nil (.concat #js [type attrs] children)))\n\n(defn component-attributes [attrs]\n  (let [x (util/camel-case-keys* attrs)]\n    (let [m (js-obj)]\n      (doseq [[k v] x]\n        (gobj/set m (name k) v))\n      m)))\n\n(defn element-attributes [attrs]\n  (when-let [js-attrs (clj->js (util/html-to-dom-attrs attrs))]\n    (let [class (.-className js-attrs)\n          class (if (array? class) (str/join \" \" class) class)]\n      (if (str/blank? class)\n        (js-delete js-attrs \"className\")\n        (set! (.-className js-attrs) class))\n      js-attrs)))\n\n(declare interpret)\n\n(defn- ^array interpret-seq\n  \"Eagerly interpret the seq `x` as HTML elements.\"\n  [x]\n  (reduce\n   (fn [^array ret x]\n     (.push ret (interpret x))\n     ret)\n   #js []\n   x))\n\n(defn element\n  \"Render an element vector as a HTML element.\"\n  [element]\n  (let [[type attrs content] (normalize/element element)]\n    (create-element type\n                    (element-attributes attrs)\n                    (interpret-seq content))))\n\n(defn fragment [[_ attrs & children]]\n  (let [[attrs children] (if (map? attrs)\n                           [(component-attributes attrs) (interpret-seq children)]\n                           [nil (interpret-seq (into [attrs] children))])]\n    (create-element js/React.Fragment attrs children)))\n\n(defn interop [[_ component attrs & children]]\n  (let [[attrs children] (if (map? attrs)\n                           [(component-attributes attrs) (interpret-seq children)]\n                           [nil (interpret-seq (into [attrs] children))])]\n    (create-element component attrs children)))\n\n(defn- interpret-vec\n  \"Interpret the vector `x` as an HTML element or a the children of an\n  element.\"\n  [x]\n  (cond\n    (util/fragment? (nth x 0 nil)) (fragment x)\n    (keyword-identical? :> (nth x 0 nil)) (interop x)\n    (util/element? x) (element x)\n    :else (interpret-seq x)))\n\n(defn interpret [v]\n  (cond\n    (vector? v) (interpret-vec v)\n    (seq? v) (interpret-seq v)\n    :else v))\n"]}