shadow$provide.module$node_modules$prop_types$checkPropTypes=function(global,require,module,exports){function checkPropTypes(typeSpecs,values,location,componentName,getStack){for(var typeSpecName in typeSpecs)if(has(typeSpecs,typeSpecName)){try{if("function"!==typeof typeSpecs[typeSpecName]){var err=Error((componentName||"React class")+": "+location+" type `"+typeSpecName+"` is invalid; it must be a function, usually from the `prop-types` package, but received `"+typeof typeSpecs[typeSpecName]+"`.");
err.name="Invariant Violation";throw err;}var error=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,ReactPropTypesSecret)}catch(ex){error=ex}!error||error instanceof Error||printWarning((componentName||"React class")+": type specification of "+location+" `"+typeSpecName+"` is invalid; the type checker function must return `null` or an `Error` but returned a "+typeof error+". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
if(error instanceof Error&&!(error.message in loggedTypeFailures)){loggedTypeFailures[error.message]=!0;var stack=getStack?getStack():"";printWarning("Failed "+location+" type: "+error.message+(null!=stack?stack:""))}}}var printWarning=function(){},ReactPropTypesSecret=require("module$node_modules$prop_types$lib$ReactPropTypesSecret"),loggedTypeFailures={},has=Function.call.bind(Object.prototype.hasOwnProperty);printWarning=function(text){text="Warning: "+text;"undefined"!==typeof console&&console.error(text);
try{throw Error(text);}catch(x){}};checkPropTypes.resetWarningCache=function(){loggedTypeFailures={}};module.exports=checkPropTypes}
//# sourceMappingURL=module$node_modules$prop_types$checkPropTypes.js.map
