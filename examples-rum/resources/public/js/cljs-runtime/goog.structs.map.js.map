{
"version":3,
"file":"goog.structs.map.js",
"lineCount":287,
"mappings":"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",
"sources":["goog/structs/map.js"],
"sourcesContent":["// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Datastructure: Hash Map.\n *\n * @author arv@google.com (Erik Arvidsson)\n *\n * This file contains an implementation of a Map structure. It implements a lot\n * of the methods used in goog.structs so those functions work on hashes. This\n * is best suited for complex key types. For simple keys such as numbers and\n * strings consider using the lighter-weight utilities in goog.object.\n */\n\n\ngoog.provide('goog.structs.Map');\n\ngoog.require('goog.iter.Iterator');\ngoog.require('goog.iter.StopIteration');\n\n\n\n/**\n * Class for Hash Map datastructure.\n * @param {*=} opt_map Map or Object to initialize the map with.\n * @param {...*} var_args If 2 or more arguments are present then they\n *     will be used as key-value pairs.\n * @constructor\n * @template K, V\n * @deprecated This type is misleading: use ES6 Map instead.\n */\ngoog.structs.Map = function(opt_map, var_args) {\n\n  /**\n   * Underlying JS object used to implement the map.\n   * @private {!Object}\n   */\n  this.map_ = {};\n\n  /**\n   * An array of keys. This is necessary for two reasons:\n   *   1. Iterating the keys using for (var key in this.map_) allocates an\n   *      object for every key in IE which is really bad for IE6 GC perf.\n   *   2. Without a side data structure, we would need to escape all the keys\n   *      as that would be the only way we could tell during iteration if the\n   *      key was an internal key or a property of the object.\n   *\n   * This array can contain deleted keys so it's necessary to check the map\n   * as well to see if the key is still in the map (this doesn't require a\n   * memory allocation in IE).\n   * @private {!Array<string>}\n   */\n  this.keys_ = [];\n\n  /**\n   * The number of key value pairs in the map.\n   * @private {number}\n   */\n  this.count_ = 0;\n\n  /**\n   * Version used to detect changes while iterating.\n   * @private {number}\n   */\n  this.version_ = 0;\n\n  var argLength = arguments.length;\n\n  if (argLength > 1) {\n    if (argLength % 2) {\n      throw new Error('Uneven number of arguments');\n    }\n    for (var i = 0; i < argLength; i += 2) {\n      this.set(arguments[i], arguments[i + 1]);\n    }\n  } else if (opt_map) {\n    this.addAll(/** @type {!Object} */ (opt_map));\n  }\n};\n\n\n/**\n * @return {number} The number of key-value pairs in the map.\n */\ngoog.structs.Map.prototype.getCount = function() {\n  return this.count_;\n};\n\n\n/**\n * Returns the values of the map.\n * @return {!Array<V>} The values in the map.\n */\ngoog.structs.Map.prototype.getValues = function() {\n  this.cleanupKeysArray_();\n\n  var rv = [];\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    rv.push(this.map_[key]);\n  }\n  return rv;\n};\n\n\n/**\n * Returns the keys of the map.\n * @return {!Array<string>} Array of string values.\n */\ngoog.structs.Map.prototype.getKeys = function() {\n  this.cleanupKeysArray_();\n  return /** @type {!Array<string>} */ (this.keys_.concat());\n};\n\n\n/**\n * Whether the map contains the given key.\n * @param {*} key The key to check for.\n * @return {boolean} Whether the map contains the key.\n */\ngoog.structs.Map.prototype.containsKey = function(key) {\n  return goog.structs.Map.hasKey_(this.map_, key);\n};\n\n\n/**\n * Whether the map contains the given value. This is O(n).\n * @param {V} val The value to check for.\n * @return {boolean} Whether the map contains the value.\n */\ngoog.structs.Map.prototype.containsValue = function(val) {\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    if (goog.structs.Map.hasKey_(this.map_, key) && this.map_[key] == val) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Whether this map is equal to the argument map.\n * @param {goog.structs.Map} otherMap The map against which to test equality.\n * @param {function(V, V): boolean=} opt_equalityFn Optional equality function\n *     to test equality of values. If not specified, this will test whether\n *     the values contained in each map are identical objects.\n * @return {boolean} Whether the maps are equal.\n */\ngoog.structs.Map.prototype.equals = function(otherMap, opt_equalityFn) {\n  if (this === otherMap) {\n    return true;\n  }\n\n  if (this.count_ != otherMap.getCount()) {\n    return false;\n  }\n\n  var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;\n\n  this.cleanupKeysArray_();\n  for (var key, i = 0; key = this.keys_[i]; i++) {\n    if (!equalityFn(this.get(key), otherMap.get(key))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n\n/**\n * Default equality test for values.\n * @param {*} a The first value.\n * @param {*} b The second value.\n * @return {boolean} Whether a and b reference the same object.\n */\ngoog.structs.Map.defaultEquals = function(a, b) {\n  return a === b;\n};\n\n\n/**\n * @return {boolean} Whether the map is empty.\n */\ngoog.structs.Map.prototype.isEmpty = function() {\n  return this.count_ == 0;\n};\n\n\n/**\n * Removes all key-value pairs from the map.\n */\ngoog.structs.Map.prototype.clear = function() {\n  this.map_ = {};\n  this.keys_.length = 0;\n  this.count_ = 0;\n  this.version_ = 0;\n};\n\n\n/**\n * Removes a key-value pair based on the key. This is O(logN) amortized due to\n * updating the keys array whenever the count becomes half the size of the keys\n * in the keys array.\n * @param {*} key  The key to remove.\n * @return {boolean} Whether object was removed.\n */\ngoog.structs.Map.prototype.remove = function(key) {\n  if (goog.structs.Map.hasKey_(this.map_, key)) {\n    delete this.map_[key];\n    this.count_--;\n    this.version_++;\n\n    // clean up the keys array if the threshold is hit\n    if (this.keys_.length > 2 * this.count_) {\n      this.cleanupKeysArray_();\n    }\n\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * Cleans up the temp keys array by removing entries that are no longer in the\n * map.\n * @private\n */\ngoog.structs.Map.prototype.cleanupKeysArray_ = function() {\n  if (this.count_ != this.keys_.length) {\n    // First remove keys that are no longer in the map.\n    var srcIndex = 0;\n    var destIndex = 0;\n    while (srcIndex < this.keys_.length) {\n      var key = this.keys_[srcIndex];\n      if (goog.structs.Map.hasKey_(this.map_, key)) {\n        this.keys_[destIndex++] = key;\n      }\n      srcIndex++;\n    }\n    this.keys_.length = destIndex;\n  }\n\n  if (this.count_ != this.keys_.length) {\n    // If the count still isn't correct, that means we have duplicates. This can\n    // happen when the same key is added and removed multiple times. Now we have\n    // to allocate one extra Object to remove the duplicates. This could have\n    // been done in the first pass, but in the common case, we can avoid\n    // allocating an extra object by only doing this when necessary.\n    var seen = {};\n    var srcIndex = 0;\n    var destIndex = 0;\n    while (srcIndex < this.keys_.length) {\n      var key = this.keys_[srcIndex];\n      if (!(goog.structs.Map.hasKey_(seen, key))) {\n        this.keys_[destIndex++] = key;\n        seen[key] = 1;\n      }\n      srcIndex++;\n    }\n    this.keys_.length = destIndex;\n  }\n};\n\n\n/**\n * Returns the value for the given key.  If the key is not found and the default\n * value is not given this will return `undefined`.\n * @param {*} key The key to get the value for.\n * @param {DEFAULT=} opt_val The value to return if no item is found for the\n *     given key, defaults to undefined.\n * @return {V|DEFAULT} The value for the given key.\n * @template DEFAULT\n */\ngoog.structs.Map.prototype.get = function(key, opt_val) {\n  if (goog.structs.Map.hasKey_(this.map_, key)) {\n    return this.map_[key];\n  }\n  return opt_val;\n};\n\n\n/**\n * Adds a key-value pair to the map.\n * @param {*} key The key.\n * @param {V} value The value to add.\n * @return {*} Some subclasses return a value.\n */\ngoog.structs.Map.prototype.set = function(key, value) {\n  if (!(goog.structs.Map.hasKey_(this.map_, key))) {\n    this.count_++;\n    // TODO(johnlenz): This class lies, it claims to return an array of string\n    // keys, but instead returns the original object used.\n    this.keys_.push(/** @type {?} */ (key));\n    // Only change the version if we add a new key.\n    this.version_++;\n  }\n  this.map_[key] = value;\n};\n\n\n/**\n * Adds multiple key-value pairs from another goog.structs.Map or Object.\n * @param {?Object} map Object containing the data to add.\n */\ngoog.structs.Map.prototype.addAll = function(map) {\n  if (map instanceof goog.structs.Map) {\n    var keys = map.getKeys();\n    for (var i = 0; i < keys.length; i++) {\n      this.set(keys[i], map.get(keys[i]));\n    }\n  } else {\n    for (var key in map) {\n      this.set(key, map[key]);\n    }\n  }\n};\n\n\n/**\n * Calls the given function on each entry in the map.\n * @param {function(this:T, V, K, goog.structs.Map<K,V>)} f\n * @param {T=} opt_obj The value of \"this\" inside f.\n * @template T\n */\ngoog.structs.Map.prototype.forEach = function(f, opt_obj) {\n  var keys = this.getKeys();\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = this.get(key);\n    f.call(opt_obj, value, key, this);\n  }\n};\n\n\n/**\n * Clones a map and returns a new map.\n * @return {!goog.structs.Map} A new map with the same key-value pairs.\n */\ngoog.structs.Map.prototype.clone = function() {\n  return new goog.structs.Map(this);\n};\n\n\n/**\n * Returns a new map in which all the keys and values are interchanged\n * (keys become values and values become keys). If multiple keys map to the\n * same value, the chosen transposed value is implementation-dependent.\n *\n * It acts very similarly to {goog.object.transpose(Object)}.\n *\n * @return {!goog.structs.Map} The transposed map.\n */\ngoog.structs.Map.prototype.transpose = function() {\n  var transposed = new goog.structs.Map();\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    var value = this.map_[key];\n    transposed.set(value, key);\n  }\n\n  return transposed;\n};\n\n\n/**\n * @return {!Object} Object representation of the map.\n */\ngoog.structs.Map.prototype.toObject = function() {\n  this.cleanupKeysArray_();\n  var obj = {};\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    obj[key] = this.map_[key];\n  }\n  return obj;\n};\n\n\n/**\n * Returns an iterator that iterates over the keys in the map.  Removal of keys\n * while iterating might have undesired side effects.\n * @return {!goog.iter.Iterator} An iterator over the keys in the map.\n */\ngoog.structs.Map.prototype.getKeyIterator = function() {\n  return this.__iterator__(true);\n};\n\n\n/**\n * Returns an iterator that iterates over the values in the map.  Removal of\n * keys while iterating might have undesired side effects.\n * @return {!goog.iter.Iterator} An iterator over the values in the map.\n */\ngoog.structs.Map.prototype.getValueIterator = function() {\n  return this.__iterator__(false);\n};\n\n\n/**\n * Returns an iterator that iterates over the values or the keys in the map.\n * This throws an exception if the map was mutated since the iterator was\n * created.\n * @param {boolean=} opt_keys True to iterate over the keys. False to iterate\n *     over the values.  The default value is false.\n * @return {!goog.iter.Iterator} An iterator over the values or keys in the map.\n */\ngoog.structs.Map.prototype.__iterator__ = function(opt_keys) {\n  // Clean up keys to minimize the risk of iterating over dead keys.\n  this.cleanupKeysArray_();\n\n  var i = 0;\n  var version = this.version_;\n  var selfObj = this;\n\n  var newIter = new goog.iter.Iterator;\n  newIter.next = function() {\n    if (version != selfObj.version_) {\n      throw new Error('The map has changed since the iterator was created');\n    }\n    if (i >= selfObj.keys_.length) {\n      throw goog.iter.StopIteration;\n    }\n    var key = selfObj.keys_[i++];\n    return opt_keys ? key : selfObj.map_[key];\n  };\n  return newIter;\n};\n\n\n/**\n * Safe way to test for hasOwnProperty.  It even allows testing for\n * 'hasOwnProperty'.\n * @param {!Object} obj The object to test for presence of the given key.\n * @param {*} key The key to check for.\n * @return {boolean} Whether the object has the key.\n * @private\n */\ngoog.structs.Map.hasKey_ = function(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n"],
"names":["goog","provide","require","structs","Map","goog.structs.Map","opt_map","var_args","map_","keys_","count_","version_","argLength","arguments","length","Error","i","set","addAll","prototype","getCount","goog.structs.Map.prototype.getCount","getValues","goog.structs.Map.prototype.getValues","cleanupKeysArray_","rv","key","push","getKeys","goog.structs.Map.prototype.getKeys","concat","containsKey","goog.structs.Map.prototype.containsKey","hasKey_","containsValue","goog.structs.Map.prototype.containsValue","val","equals","goog.structs.Map.prototype.equals","otherMap","opt_equalityFn","equalityFn","defaultEquals","get","goog.structs.Map.defaultEquals","a","b","isEmpty","goog.structs.Map.prototype.isEmpty","clear","goog.structs.Map.prototype.clear","remove","goog.structs.Map.prototype.remove","goog.structs.Map.prototype.cleanupKeysArray_","srcIndex","destIndex","seen","goog.structs.Map.prototype.get","opt_val","goog.structs.Map.prototype.set","value","goog.structs.Map.prototype.addAll","map","keys","forEach","goog.structs.Map.prototype.forEach","f","opt_obj","call","clone","goog.structs.Map.prototype.clone","transpose","goog.structs.Map.prototype.transpose","transposed","toObject","goog.structs.Map.prototype.toObject","obj","getKeyIterator","goog.structs.Map.prototype.getKeyIterator","__iterator__","getValueIterator","goog.structs.Map.prototype.getValueIterator","goog.structs.Map.prototype.__iterator__","opt_keys","version","selfObj","newIter","iter","Iterator","next","newIter.next","StopIteration","goog.structs.Map.hasKey_","Object","hasOwnProperty"]
}
